\documentclass[ignorenonframetext,red]{beamer}
%\documentclass[ignorenonframetext,red,handout]{beamer}\usepackage{pgfpages}\pgfpagesuselayout{4 on 1}[letterpaper, landscape, border shrink=5mm]
%\documentclass{article}\usepackage{beamerarticle}
\usepackage{listings}
\usepackage{hyperref}

\mode<article>{\usepackage{fullpage}}

% code formatting options
\lstdefinestyle{numbers}{ %
  numbers=left, %
  stepnumber=1, %
  numberstyle=\small, %
  numbersep=10pt, %
  showspaces=false, %
  showstringspaces=false, %
  showtabs=false, %
}
\lstdefinestyle{python}{ %
  language=Python, %
  style=numbers, %
  keywordstyle=\color{olive}, %
  commentstyle=\color{red}, %
  stringstyle=\color{teal}
}
\lstdefinestyle{csharp}{ %
  language=[Sharp]C, %
  style=numbers, %
  keywordstyle=\color{blue}, %
  commentstyle=\color{olive}, %
  stringstyle=\color{purple}
}

\title{Functional Programming Concepts}
\author{Philip Hanson}
\institute{Jibunu LLC}
\date{November 8, 2012}

\AtBeginSection[]%
{
\begin{frame}<beamer>
	\tableofcontents[currentsection]
\end{frame}
}

\AtBeginSubsection[]%
{
\begin{frame}<beamer>
	\tableofcontents[currentsection,currentsubsection]
\end{frame}
}

\begin{document}

\begin{frame}
\maketitle
\end{frame}

\section{Concepts}

\begin{frame}
Before diving into examples that use a functional style, let's establish what \textit{functional} means, and examine the core concepts of functional programming.
\end{frame}%
As the name implies, functional programming centers around \textit{functions} and their transformations of inputs into outputs. This can be seen in the way that a functional style tends to decompose a given problem.

\subsection{Decomposition Paradigms}
\begin{frame}
Programming languages support problem decomposition in several ways:
\begin{itemize}
\pause \item procedural (C, Pascal, BASH, Batch)
\pause \item declarative (SQL)
\pause \item object-oriented (Smalltalk, C++, Java, C\#)
\pause \item functional (Scheme, Haskell, ML)
\end{itemize}
\end{frame}

\begin{frame}
\noindent There are important differences in appearance and functionality when programming in different paradigms.
\pause
\begin{block}{Object-Oriented}
``Objects are little capsules containing some internal state along with a collection of method calls that let you modify this state, and programs consist of making the right set of state changes.''
\end{block}
\pause
\begin{block}{Functional}
``Functional programming wants to avoid state changes as much as possible and works with data flowing between functions.''
\end{block}
\end{frame}

\subsection{Functional Design}
\begin{frame}
\noindent Why is functional programming useful?
\begin{itemize}
\pause \item Formal provability
\pause \item Modularity
\pause \item Composability
\pause \item Ease of debugging and testing
\end{itemize}
\end{frame}

\noindent The above are useful to varying degrees. Formal provability, for example, is a great idea, but trying to prove anything non-trivial involves a lot of work---so it's not very practical. A more practical benefit of functional programming is that it forces you to break your problem into small pieces, resulting in more modular programs.  It’s easier to specify and write (and test!) a small function that does one thing than a large function that performs a complicated transformation.

Debugging is simplified because functions are generally small and clearly specified. When a program doesn’t work, each function is an interface point where you can check that the data are correct. You can look at the intermediate inputs and outputs to quickly isolate the function that’s responsible for a bug.

Testing is easier because each function is a potential subject for a unit test. Functions don’t depend on system state that needs to be replicated before running a test; instead you only have to synthesize the right input and then check that the output matches expectations.

\subsection{First-Class Functions and Immutability}
\begin{frame}
Functional programs are organized around \textit{functions}
\end{frame}%
instead of objects. In a functional programming language, you can hold a reference to a function---or more generally, a \textit{callable object} that accepts parameters and returns some result.

This implies the existence of some other features you may have heard of, like \textit{anonymous functions}, where the body of a function can be defined without assigning it to a specific name. The ability to work with functions in this way is referred to as making them \textit{first-class}, that is, referenceable. (It also opens the door to \textit{higher-order} functions, which are functions that accept other functions as parameters.)

\begin{frame}
Functions with no side effects are called \textit{pure functions}%
\end{frame}.
Some functional programming languages enforce functional purity unless the function is tagged to allow it to be \textit{impure}.
\begin{frame}%
Data structures are generally \textit{immutable}. An immutable object has a couple of useful properties:
\begin{itemize}
\pause \item objects cannot be changed in-place
\pause \item any operation that would change some property of an object must create a copy instead
\end{itemize}
\end{frame}
\noindent Because immutable objects cannot change, we can be sure that any reference we hold to an object will remain stable and will always contain the same information. And because pure functions have no side effects, we can guarantee that a given function call won't affect any mutable objects, either.

\section{Techniques}
\begin{frame}
Let's examine some distinctive techniques of functional programming using Python (\url{http://www.python.org}).
\end{frame}%
I've chosen to use Python for these examples because it allows us to write code in a functional style while retaining a familiar, easy-to-read syntax. Note that Python is a \textit{multi-paradigm} language rather than a purely functional language; you can write procedural programs, object-oriented programs, and functional programs all in Python.

\subsection{\tt sorted}
We have an excellent example of a pure function in the Python standard library, \texttt{sorted}. The function accepts an \texttt{iterable} and returns a sorted version of that object, leaving the original untouched.

\begin{frame}[fragile]
\begin{lstlisting}[style=python,caption={Sorting a List},label={lst:sorted}]
n = [4,8,2,6,5,9,7,1]   # original list
p = sorted(n)           # sorted copy
\end{lstlisting}
\end{frame}

\noindent If we run the code of Listing \ref{lst:sorted} in a REPL and then examine the variable values, we'll find that \texttt{n} retains its original value, while \texttt{p} contains a sorted version of the same information.

\subsection{\tt filter}
This next function shows an example of higher-order functions. As you might expect from the name, \texttt{filter} returns a filtered version of a list. But it does so using a \textit{predicate} function that is passed in along with the list to be filtered.

\begin{frame}[fragile]
\begin{lstlisting}[style=python,caption={Filtering a List},label={lst:filter1}]
def p(n):  # predicate
    return n > 3

r = [1,2,3,4,5]
m = filter(p, r)
\end{lstlisting}

\begin{lstlisting}[style=python,caption={Anonymous Functions},label={lst:filter2}]
r = [1,2,3,4,5]
m = filter(lambda x: x > 3, r)  # anonymous predicate
\end{lstlisting}
\end{frame}

Listing \ref{lst:filter1} shows a reference to the function \texttt{p} being passed as a parameter to \texttt{filter}, which returns an enumerable object. This enumerable contains all elements of the original list for which the predicate (in this case, \texttt{p}) returns \texttt{true}. Thus, the iterator \texttt{m} will produce the values \texttt{[4,5]}.

It is not even necessary to hold a reference to the predicate function: Python allows us to define anonymous functions using the \texttt{lambda} keyword. Anonymous functions can be used anywhere that a function reference is required. Listing \ref{lst:filter2} shows the use of an anonymous function in place of \texttt{p} as a parameter for \texttt{filter}.

\subsection{\tt map}
Filtering is nice (and useful), but often we want to do more with the values in an enumerable, such as \textit{transform} them.

\begin{frame}[fragile]
\begin{lstlisting}[style=python,caption={Doubling Each Element},label={lst:map1}]
r = [1,2,3,4,5]
m = map(lambda x: x * 2, r)
\end{lstlisting}
\end{frame}

\subsection{\tt reduce}

% also: putting it all together. reduce(x, map(y, filter(z, r)))

\section{Functional Programming in C\#}
\begin{frame}
% immutable objects (+ example from survey model code)
% delegates and anonymous methods
% our glorious future: C\#4, lambdas, LINQ to objects
\end{frame}

\begin{frame}{Resources}
\begin{itemize}
	\item Python Functional Programming HOWTO\\(\url{http://docs.python.org/3/howto/functional.html})
	\item Python {\tt functools} Documentation\\(\url{http://docs.python.org/3/library/functools.html})
\end{itemize}
\end{frame}

\end{document}
